-- CREATING TABLES

--Table BOOK
--Primary key: BID
--It checks the price so that it must be a positive number
CREATE TABLE BOOK(
	BID NUMBER(10) NOT NULL,
	TITLE CHAR(30) NOT NULL,
	AUTHOR CHAR(30) NOT NULL,
	PRICE REAL NOT NULL,
	STOCK INTEGER NOT NULL,
	PRIMARY KEY (BID),
	CHECK(PRICE > 0));


--Table STUDENT
--Primary key: SID
CREATE TABLE STUDENT(
	SID NUMBER(10) NOT NULL,
	NAME CHAR(20) NOT NULL,
	GENDER CHAR(1) NOT NULL,
	MAJOR CHAR(20) NOT NULL,
	DISCOUNT REAL DEFAULT 0,
	PRIMARY KEY (SID));

--Table ORDERS
--Primary key: ORDER_ID
--Foreign key: SID
CREATE TABLE ORDERS(
	ORDER_ID CHAR(20) NOT NULL,
	SID NUMBER(10) NOT NULL,
	TOTAL_PRICE REAL DEFAULT 0,
	PAYMENT_METHOD CHAR(4) NOT NULL,
	CARD_NO CHAR(16),
	ORDER_DATE DATE DEFAULT SYSDATE NOT NULL,
	PRIMARY KEY(ORDER_ID),
	FOREIGN KEY(SID) REFERENCES STUDENT ON DELETE CASCADE);

--Table ORDER_ITEM
--PRIMARY KEY: BID, ORDER_ID
--FOREIGN KEY: BID, ORDER_ID
CREATE TABLE ORDER_ITEM(
	ORDER_ID CHAR(20) NOT NULL,
	BID NUMBER(10) NOT NULL,
	QUANTITY INTEGER NOT NULL,
	PRICE REAL NOT NULL,
	ADDRESS CHAR(30) NOT NULL,
	EMAIL CHAR(20) NOT NULL,
	ORDER_STATUS CHAR(20) DEFAULT 'CONFIRMED',
	DELIVERY_DATE DATE,
	PRIMARY KEY (BID, ORDER_ID),
	FOREIGN KEY (BID) REFERENCES BOOK ON DELETE CASCADE,
	FOREIGN KEY (ORDER_ID) REFERENCES ORDERS(ORDER_ID) ON DELETE CASCADE);



-- INSERTING DATA FOR UPCOMING TEST CASES
INSERT INTO BOOK VALUES (1, 'Harry Potter I', 'J.K. Rowling', 300, 10);
INSERT INTO BOOK VALUES (2, 'Harry Potter II', 'J.K. Rowling', 300, 0);
INSERT INTO BOOK VALUES (3, 'Harry Potter III', 'J.K. Rowling', 300, 20);


INSERT INTO STUDENT(SID, NAME, GENDER, MAJOR, DISCOUNT) VALUES (1, 'Kurt', 'M', 'Computer Science', 10);
INSERT INTO STUDENT(SID, NAME, GENDER, MAJOR) VALUES (2, 'Rex', 'M', 'Computer Science');
INSERT INTO STUDENT(SID, NAME, GENDER, MAJOR) VALUES (3, 'Jerry', 'M', 'Computer Science');


INSERT INTO ORDERS(ORDER_ID, SID, TOTAL_PRICE, PAYMENT_METHOD, CARD_NO) VALUES('1', 2, 600, 'CASH', '');
INSERT INTO ORDERS(ORDER_ID, SID, TOTAL_PRICE, PAYMENT_METHOD, CARD_NO, ORDER_DATE) VALUES('2', 1, 300, 'CASH','', '10-APR-2020');


INSERT INTO ORDER_ITEM VALUES('1', 1, 1, 300, 'Hong Kong', 'Rex02@gmail.com', 'DELIVERED', '21-APR-2020');
INSERT INTO ORDER_ITEM VALUES('1', 2, 1, 300, 'Hong Kong', 'Rex02@gmail.com', 'SHIPPING', '');
INSERT INTO ORDER_ITEM VALUES('2', 1, 1, 300, 'Hong Kong', 'Kurt01@gmail.com', 'SHIPPING', '');



-- TRIGGER TO UPDATE DISCOUNT OF THE STUDENT WHEN ORDER DELETED
-- DISCOUNT is 1% of the TOTAL_PRICE in the ORDERS table 
CREATE OR REPLACE TRIGGER ALL_ORDERS_DELETE
AFTER DELETE ON ORDERS
FOR EACH ROW
BEGIN
	UPDATE STUDENT 
	SET DISCOUNT = DISCOUNT - :old.TOTAL_PRICE/100 
	WHERE SID = :old.SID;
END;
.
/

-- TRIGGER TO UPDATE STOCK, DISCOUNT AND TOTAL PRICE
-- WHEN NEW ORDER ITEM IS INSERTED
CREATE OR REPLACE TRIGGER ORDER_ITEM_INSERT
AFTER INSERT ON ORDER_ITEM
FOR EACH ROW
DECLARE C REAL;
BEGIN
	UPDATE BOOK 
	SET STOCK = STOCK - :new.QUANTITY 
	WHERE BID = :new.BID;

	-- Get total price of orders made this year
	SELECT SUM(TOTAL_PRICE) INTO C 
	FROM ORDERS 
	WHERE SID IN (SELECT SID 
				FROM ORDERS 
				WHERE ORDER_ID = :new.ORDER_ID) AND 
				TO_CHAR(ORDER_DATE, 'YYYY') = TO_CHAR(SYSDATE, 'YYYY');

	-- Update discount of the student as 1% of price of all orders made this year
	UPDATE STUDENT 
	SET DISCOUNT = C / 100
	WHERE SID IN (SELECT SID 
				FROM ORDERS 
				WHERE ORDER_ID = :new.ORDER_ID);

	SELECT DISCOUNT INTO C 
	FROM STUDENT 
	WHERE SID IN (SELECT SID 
				FROM ORDERS 
				WHERE ORDER_ID = :new.ORDER_ID);
	
	-- Adjust discount so that it is either 0, 10 or 20
	IF(C >= 20) THEN
		C:=20;
	ELSIF(C>=10) THEN
		C:=10;
	ELSIF(C<10) THEN
		C:=0;
	END IF;
	
	-- Update total price of the order in the ORDERS table using student's discount
	UPDATE ORDERS
	SET TOTAL_PRICE = TOTAL_PRICE + (:new.PRICE * (1 - (C/100))) 
	WHERE ORDERS.ORDER_ID = :new.ORDER_ID;
	
	-- Update student's discount by adding 1% of the price of the new order
	UPDATE STUDENT 
	SET DISCOUNT = DISCOUNT + (:new.PRICE/100) 
	WHERE SID IN (SELECT SID 
				FROM ORDERS 
				WHERE ORDER_ID = :new.ORDER_ID);
END;
.
/


-- TRIGGER FOR INCREMENTING STOCK IN BOOK AFTER DELETING NEW ORDER_ITEM
CREATE OR REPLACE TRIGGER ORDER_ITEM_DELETE
AFTER DELETE ON ORDER_ITEM
FOR EACH ROW
BEGIN
	UPDATE BOOK SET STOCK = STOCK + :old.QUANTITY WHERE BID = :old.BID;
END;
.
/


-- TRIGGER TO RAISE ERROR IF QUANTITY IS NEGATIVE 
-- OR IF STOCK = 0 
-- OR IF IT IS NOT ENOUGH
CREATE OR REPLACE TRIGGER STOCK_EMPTY_CONSTRAINT
BEFORE INSERT ON ORDER_ITEM
FOR EACH ROW
DECLARE c INTEGER;
BEGIN
	IF(:new.QUANTITY <= 0) THEN
		RAISE_APPLICATION_ERROR(-20000, 'THE QUANTITY NUMBER IS INVALID!');
	END IF;
	
	SELECT STOCK INTO c 
	FROM BOOK 
	WHERE BOOK.BID = :new.BID;
	
	IF(c = 0) THEN
			RAISE_APPLICATION_ERROR(-20000, 'THE BOOK IS OUT OF STOCK!');
	ELSIF(c < :new.QUANTITY) THEN
			RAISE_APPLICATION_ERROR(-20000, 'THERE IS NOT ENOUGH BOOK IN STOCK!');
	END IF;
END;
.
/

-- TRIGGER TO CHECK CARD_NO IN ORDERS
CREATE OR REPLACE TRIGGER CARD_NO_CONSTRAINT
BEFORE INSERT ON ORDERS
FOR EACH ROW
BEGIN
	IF((:new.PAYMENT_METHOD = 'card' OR :new.PAYMENT_METHOD = 'CARD') AND :new.CARD_NO IS NULL) THEN
			RAISE_APPLICATION_ERROR(-20000, 'EMPTY CARD NO.!');
	END IF;
END;
.
/


-- TRIGGER TO CHECK ORDER_DATE BEFORE DELETION
-- If order date was more than a week ago: reject cancellation
CREATE OR REPLACE TRIGGER ORDER_DATE_CHECK_ON_DELETE
BEFORE DELETE ON ORDERS
FOR EACH ROW
BEGIN
	IF(CURRENT_DATE - :old.ORDER_DATE >= 7) THEN
		RAISE_APPLICATION_ERROR(-20000, 'THE ORDER WAS MADE MORE THAN A WEEK AGO!');
	END IF;
END;
.
/


-- TRIGGER TO CHECK ORDER_STATUS BEFORE DELETION
-- If order is already delivered: reject cancellation
CREATE OR REPLACE TRIGGER ORDER_STATUS_CHECK_ON_DELETE
BEFORE DELETE ON ORDER_ITEM
FOR EACH ROW
BEGIN
	IF(:old.ORDER_STATUS = 'DELIVERED') THEN
		RAISE_APPLICATION_ERROR(-20000, 'THE ORDER IS ALREADY DELIVERED!');
	END IF;
END;
.
/


-- TRIGGER TO CHECK OUTSTANDING ORDERS BEFORE INSERTION
-- If student has outstanding orders: reject new order
CREATE OR REPLACE TRIGGER ORDER_STATUS_CHECK_ON_INSERT
BEFORE INSERT ON ORDERS
FOR EACH ROW
DECLARE 
	N INTEGER; M INTEGER;
BEGIN
	SELECT COUNT(*) INTO M --Get number of orders of the student from ORDERS table
	FROM ORDERS 
	WHERE SID = :new.SID;
	
	-- if there is at least one order:
	-- get the number of undelivered orderd
	IF(M != 0) THEN
		SELECT COUNT(*) INTO N 
		FROM ORDER_ITEM 
		WHERE ORDER_ID IN (SELECT ORDER_ID 
							FROM ORDERS 
							WHERE SID = :new.SID) AND ORDER_STATUS != 'DELIVERED';
		
		-- if there is at least one undelivered order, reject new order
		IF(N > 0) THEN
			RAISE_APPLICATION_ERROR(-20000, 'THIS STUDENT HAS AN OUTSTANDING ORDER!');
		END IF;
	END IF;
END;
.
/